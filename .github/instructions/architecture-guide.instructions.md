---
applyTo: '**'
---

# アーキテクチャガイド

## 設計原則

### SOLID原則
- **Single Responsibility Principle**: 単一責任の原則
- **Open/Closed Principle**: 開放/閉鎖の原則
- **Liskov Substitution Principle**: リスコフの置換原則
- **Interface Segregation Principle**: インターフェース分離の原則
- **Dependency Inversion Principle**: 依存関係逆転の原則

### DRY (Don't Repeat Yourself)
- 重複コードを避ける
- 共通処理は関数・クラスとして抽出
- 設定値の重複を避ける

### KISS (Keep It Simple, Stupid)
- シンプルで理解しやすい設計
- 不必要な複雑さを避ける
- 明確で直感的なインターフェース

## アーキテクチャパターン

### レイヤードアーキテクチャ
```
┌─────────────────────┐
│   Presentation      │ ← UI層（画面、API）
├─────────────────────┤
│   Application       │ ← アプリケーション層（ビジネスロジック）
├─────────────────────┤
│   Domain            │ ← ドメイン層（ドメインモデル）
├─────────────────────┤
│   Infrastructure    │ ← インフラ層（データアクセス、外部連携）
└─────────────────────┘
```

#### 適用場面
- 中規模以上のアプリケーション
- 複雑なビジネスロジックを含む場合
- 保守性・拡張性を重視する場合

### マイクロサービスアーキテクチャ
- 機能別にサービスを分割
- 独立したデプロイ・スケーリング
- 技術スタックの多様性

#### 適用場面
- 大規模なシステム
- 複数チームでの開発
- 高い可用性が要求される場合

### イベント駆動アーキテクチャ
- 非同期処理によるシステム間連携
- 疎結合な設計
- イベントソーシングパターン

#### 適用場面
- リアルタイム性が重要
- システム間の連携が複雑
- スケーラビリティが重要

## 設計パターン

### 作成パターン
- **Factory Pattern**: オブジェクト生成の抽象化
- **Builder Pattern**: 複雑なオブジェクトの段階的構築
- **Singleton Pattern**: インスタンスの単一化

### 構造パターン
- **Adapter Pattern**: インターフェースの変換
- **Decorator Pattern**: 機能の動的追加
- **Facade Pattern**: 複雑なサブシステムの簡素化

### 振る舞いパターン
- **Observer Pattern**: 状態変更の通知
- **Strategy Pattern**: アルゴリズムの切り替え
- **Command Pattern**: 操作のオブジェクト化

## データアーキテクチャ

### データベース設計
#### 正規化
- 第1正規形〜第3正規形を基本とする
- 必要に応じて非正規化を検討
- データの整合性を重視

#### インデックス戦略
- 検索条件に応じた適切なインデックス
- 複合インデックスの活用
- パフォーマンスの定期的な監視

### データ管理パターン
- **Repository Pattern**: データアクセスの抽象化
- **Unit of Work Pattern**: トランザクション管理
- **CQRS Pattern**: コマンドとクエリの分離

## API設計

### RESTful API
- 適切なHTTPメソッドの使用
- リソース指向の設計
- ステートレスな通信

#### エンドポイント設計
```
GET    /api/users          # ユーザー一覧取得
GET    /api/users/{id}     # 特定ユーザー取得
POST   /api/users          # ユーザー作成
PUT    /api/users/{id}     # ユーザー更新
DELETE /api/users/{id}     # ユーザー削除
```

### GraphQL
- 柔軟なデータ取得
- 型安全性の確保
- 効率的なデータフェッチング

### WebSocket
- リアルタイム通信
- 双方向通信
- 接続管理の考慮

## セキュリティアーキテクチャ

### 認証・認可
- JWT（JSON Web Token）の活用
- OAuth 2.0 / OpenID Connect
- 多要素認証の実装

### データ保護
- 暗号化（保存時・転送時）
- 個人情報保護
- アクセスログの記録

### セキュリティ対策
- OWASP Top 10への対応
- 定期的なセキュリティ監査
- 脆弱性スキャンの実施

## パフォーマンス設計

### キャッシュ戦略
- メモリキャッシュ（Redis、Memcached）
- CDN活用
- データベースクエリキャッシュ

### スケーリング戦略
- 水平スケーリング vs 垂直スケーリング
- ロードバランシング
- データベースのシャーディング

### 監視・観測
- APM（Application Performance Monitoring）
- ログ集約・分析
- メトリクス収集・可視化

## 品質属性

### 可用性
- 冗長化設計
- 障害検知・自動復旧
- 災害復旧計画

### 保守性
- モジュール分割
- 依存関係の管理
- コードの可読性

### 拡張性
- プラグインアーキテクチャ
- 設定の外部化
- インターフェースの安定性

## 技術選択ガイド

### フロントエンド
- **React**: 大規模なSPA、豊富なエコシステム
- **Vue.js**: 学習コストが低い、段階的導入
- **Angular**: エンタープライズ向け、フルスタックフレームワーク

### バックエンド
- **Node.js**: JavaScript統一、高い並行性
- **Python**: AI/ML、豊富なライブラリ
- **Java**: エンタープライズ、安定性

### データベース
- **PostgreSQL**: RDBMS、高機能
- **MongoDB**: NoSQL、柔軟性
- **Redis**: キャッシュ、高速アクセス
